<!doctype html><html lang=en><head><title>DFIR Journey: DC Forensics — Case of the Szechuan Sauce :: RoninSec - Cyber Journal</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hands-on write-up of DFIRMadness Case 001 — exploring memory, disk and network evidence for coreupdater / Meterpreter on a domain controller."><meta name=keywords content="DFIRMadness,Szechuan Sauce,coreupdater,Meterpreter,spoolsv,mactime"><meta name=robots content="noodp"><link rel=canonical href=https://BioCreates.github.io/posts/stolen-szechuan-sauce-journey/><link rel=stylesheet href=https://BioCreates.github.io/css/custom.min.2707a48b3c4cb7c495ff47581f9533e9f6f3ffeb9c1f0bb8ac2ba5ae94c0f96b.css><link rel=stylesheet href=https://BioCreates.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://BioCreates.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://BioCreates.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://BioCreates.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://BioCreates.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://BioCreates.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://BioCreates.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://BioCreates.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://BioCreates.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://BioCreates.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://BioCreates.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://BioCreates.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://BioCreates.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://BioCreates.github.io/terminal.css><link rel="shortcut icon" href=https://BioCreates.github.io/favicon.png><link rel=apple-touch-icon href=https://BioCreates.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="DFIR Journey: DC Forensics — Case of the Szechuan Sauce"><meta property="og:description" content="Hands-on write-up of DFIRMadness Case 001 — exploring memory, disk and network evidence for coreupdater / Meterpreter on a domain controller."><meta property="og:url" content="https://BioCreates.github.io/posts/stolen-szechuan-sauce-journey/"><meta property="og:site_name" content="RoninSec - Cyber Journal"><meta property="og:image" content="https://BioCreates.github.io/posts/stolen-szechuan-sauce-journey/cover.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-09-29 12:00:00 -0400 -0400"><link rel=stylesheet href=/css/custom.min.2707a48b3c4cb7c495ff47581f9533e9f6f3ffeb9c1f0bb8ac2ba5ae94c0f96b.css integrity="sha256-JwekizxMt8SV/0dYH5Uz6fbz/+ucHwu4rCulrpTA+Ws="></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>RoninSec</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://BioCreates.github.io/posts/stolen-szechuan-sauce-journey/>DFIR Journey: DC Forensics — Case of the Szechuan Sauce</a></h1><div class=post-meta><time class=post-date>2025-09-29</time><span class=post-author>RoninSec</span><span class=post-reading-time>31 min read (6436 words)</span></div><span class=post-tags>#<a href=https://BioCreates.github.io/tags/dfir/>dfir</a>&nbsp;
#<a href=https://BioCreates.github.io/tags/windows-forensics/>windows-forensics</a>&nbsp;
#<a href=https://BioCreates.github.io/tags/memory-forensics/>memory-forensics</a>&nbsp;
#<a href=https://BioCreates.github.io/tags/timeline/>timeline</a>&nbsp;
#<a href=https://BioCreates.github.io/tags/malware/>malware</a>&nbsp;
#<a href=https://BioCreates.github.io/tags/network/>network</a>&nbsp;
</span><img src=/posts/stolen-szechuan-sauce-journey/cover.png class=post-cover alt="DFIR Journey: DC Forensics — Case of the Szechuan Sauce" title="Cover Image"><div class=post-content><div><h1 id=dfir-dc-forensics--case-of-the-szechuan-sauce>DFIR: DC Forensics — Case of the Szechuan Sauce<a href=#dfir-dc-forensics--case-of-the-szechuan-sauce class=hanchor arialabel=Anchor>#</a></h1><p>A hands-on memory, network, and disk analysis reproducing DFIRMadness Case 001; RDP intrusion → Meterpreter → timeline & IOCs.</p><p>This is my experience following the <a href=https://dfirmadness.com/the-stolen-szechuan-sauce/>DFIRMadness Case 001 - The Stolen Szechuan Sauce</a></p><p>I learned a lot about DFIR, the tools used to do this such as Volatility2 and plugins, Plaso Log2Timeline, Floss, Cape, Clamscan, ewfmount, FTK Imager, mmls, Registry explorer and a few other things along with some hiccups along the way due to the age of the post some things would not work. I analyzed memory dumps, PCAP and Disk Images. As well as worked with Plaso&rsquo;s Log2Timeline and used Mark Zimmerman&rsquo;s Timeliner tool to parse through the log and using relevant Event IDs and IOC&rsquo;s found during the various posts</p><p>At the start In order to keep with the Author &ldquo;James&rdquo; suggestions I decided to follow the guide <a href=https://dfirmadness.com/building-a-dfir-analysis-fort/>here</a> to set up a DFIR Station using SANS SIFT Workstation. Unfortunately I could not get to integrate it with the Remnux image but I will continue my attempts on that on another day. Instead what I did was create the SIFT workstation and was able to run all of the needed commands and tests there.. with some minor hiccups and gotchas. I will elaborate more on that throughout this post as necessary.</p><p>I learned A LOT during this, but I also realized how much more there is out there. As Socrates stated &ldquo;The more you learn the more you realize how little you know&rdquo;</p><h2 id=the-beginning>The Beginning<a href=#the-beginning class=hanchor arialabel=Anchor>#</a></h2><p>I started by setting up the SIFT workstation VM, when launching it, I would keep freezing up, if you look towards the right of the screenshot below it was blurred and froze there
<img src=SIFTWorkstationFreeze.png alt=SIFTWorkstationFreeze class=left></p><p>After some troubleshooting I noticed the following was the fix:
Had to change Graphic Controller to VMSVGA
<img src=VMGraphic.png alt=VMGraphic class=left></p><h2 id=sift-workstation-online>SIFT Workstation Online<a href=#sift-workstation-online class=hanchor arialabel=Anchor>#</a></h2><p>Once the SIFT VM was operational I took a snapshot in VirtualBox as I believe you should do with any fresh VM in case something goes wrong and you need to go back to a stable edition</p><p>For some reason despite the VM having bridged mode enabled, I could not get it to get an IP. Ran sudo dhclient enp0s17 to get an IP
<img src=dhclient.png alt=dhclient class=left></p><p>After it had an IP I ran the basic sudo apt update then upgrade. once that was done I took another snapshot</p><blockquote><p><strong>Time note:</strong> All times shown are <strong>UTC</strong> unless noted; some screenshots reflect <strong>local time</strong> based on the tool’s default.</p></blockquote><h2 id=memory-analysis>Memory Analysis<a href=#memory-analysis class=hanchor arialabel=Anchor>#</a></h2><p>Each artifact was available for download on the main case 001 page <a href=https://dfirmadness.com/the-stolen-szechuan-sauce/>here</a></p><p>I downloaded the memory zip file &ldquo;DC01-memory.zip&rdquo;</p><p>Sha256sum for that file is</p><p>86658d85d8254e8d30dccc4f50d9c2a8b550a101d2e78a6d932316849e37ad80 DC01-memory.zip</p><p>There is plenty covered in the actual post over at DFIRMadness so I won&rsquo;t go into that much detail. This is just a record of my efforts to understand, learn and experience the case of the Szechuan sauce.</p><p>Moving on..I don</p><p>I ran the following volatility commands/plugins</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ vol.py -f citadeldc01.mem pstree|tee pstree.out
</span></span></code></pre></div><img src=pstree.png alt=pstree class=left><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ vol.py -f citadeldc01.mem pslist|tee pslist.out
</span></span></code></pre></div><img src=pslist.png alt=pslist class=left><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ vol.py -f citadeldc01.mem malfind|tee malfind.out
</span></span></code></pre></div><img src=malfind.png alt=malfind class=left><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ vol.py -f citadeldc01.mem netscan|tee netscan.out
</span></span></code></pre></div><img src=netscan.png alt=netscan class=left><p>The explanations and findings are thoroughly explained on the DFIR Madness site so I&rsquo;ll try to just keep it short so it&rsquo;s not too much to read. This case took me 2 weeks to complete so condensing it without omitting critical details will be a challenge.</p><p>Continuing&mldr;</p><p>As you can see above I created a few output files
<img src=memoryls.png alt=memoryls class=left></p><p>While looking through netscan.out I used less to easily search for keywords</p><p>command I used is below</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>less -N -S netscan.out
</span></span></code></pre></div><p>Once in less I used &ldquo;/ESTABLISHED&rdquo; to parse for established connections in the logs
<img src=lessestablishedfilter.png alt=lessestablishedfilter class=left></p><img src=establishednentscan.png alt=establishednentscan class=left><p>Used the following command to find all of the services in question with Established connections</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ grep -Ei <span class=s1>&#39;(ismserv\.exe|lsass\.exe|coreupdater\.ex|dfssvc\.exe|dfsrs\.exe)&#39;</span> netscan.out <span class=p>|</span> grep -E <span class=s1>&#39;ESTABLISHED&#39;</span> <span class=p>|</span> less -N -S
</span></span></code></pre></div><img src=lessgrepnetscan.png alt=lessgrepnetscan class=left><p>There were a few services with established connections. So I researched them and found the following</p><h3 id=ismservexe><code>ismserv.exe</code><a href=#ismservexe class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Name/role:</strong> <em>Intersite Messaging</em> service (AD inter-site replication over SMTP).</li><li><strong>Path:</strong> <code>C:\Windows\System32\ismserv.exe</code> (Service name: <code>IsmServ</code>).</li><li><strong>Is it common?</strong> Rare today. Most AD sites use RPC, not SMTP. Often <strong>Disabled/Manual</strong>.</li><li><strong>Network behavior:</strong> Usually <strong>no connections</strong> unless SMTP-based replication is explicitly configured. No reason to talk to the public Internet.</li><li><strong>Proc count:</strong> <strong>1</strong> if running at all.</li><li><strong>Red flags:</strong> Running on a DC without a reason, unexpected outbound, wrong path, or odd parent.</li></ul><h3 id=lsassexe><code>lsass.exe</code><a href=#lsassexe class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Name/role:</strong> <em>Local Security Authority Subsystem Service</em> (auth, tokens, on DC it also hosts KDC/LDAP).</li><li><strong>Path:</strong> <code>C:\Windows\System32\lsass.exe</code> (protected; parent should be <code>wininit.exe</code>).</li><li><strong>Network behavior (DC):</strong> <strong>LISTENING</strong> on LDAP/LDAPS (389/636), Kerberos (88), kpasswd (464), RPC endpoint mapper (135) + dynamic RPC; <strong>ESTABLISHED</strong> to <strong>other DCs/clients</strong>. <strong>Not</strong> to random Internet IPs.</li><li><strong>Proc count:</strong> <strong>exactly 1</strong> legit instance.</li><li><strong>Red flags:</strong> >1 instance, wrong path (e.g., <code>C:\Users\...\lsass.exe</code>), Internet egress, suspicious parent, unsigned.</li></ul><h3 id=coreupdaterexe-3rd-party-updater-name-varies--main-suspect><code>coreupdater.exe</code> <em>(3rd-party updater name; varies)</em> &ndash; Main Suspect<a href=#coreupdaterexe-3rd-party-updater-name-varies--main-suspect class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Name/role:</strong> generic “updater” name used by legit apps (Corel/Adobe/etc.) <strong>and</strong> by malware.</li><li><strong>Path/company:</strong> depends—<strong>must check</strong> file path, signer, hash.</li><li><strong>Network behavior:</strong> Legit updaters often do <strong>HTTPS (443) to vendor domains</strong>. On a <strong>Domain Controller</strong>, any consumer-style updater is <strong>odd</strong>.</li><li><strong>Proc count:</strong> usually <strong>1</strong> on demand or via a scheduled task.</li><li><strong>Red flags:</strong> runs as <code>SYSTEM</code>, lives in temp/odd folders, unsigned, arbitrary cloud IPs, runs on a DC, strange parent (<code>svchost.exe</code> rarely launches updaters).</li></ul><h3 id=dfssvcexe-dfs-distributed-file-system><code>dfssvc.exe</code> DFS (Distributed File System)<a href=#dfssvcexe-dfs-distributed-file-system class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Name/role:</strong> <em>DFS Namespace</em> service (DFSn—manages DFS namespace referrals).</li><li><strong>Path:</strong> <code>C:\Windows\System32\dfssvc.exe</code> (Service: <code>Dfs</code>).</li><li><strong>Network behavior:</strong> RPC (135 + high ports) with <strong>domain members and other namespace servers</strong>. <strong>LAN only</strong>; Internet egress uncommon.</li><li><strong>Proc count:</strong> <strong>1</strong>.</li><li><strong>Red flags:</strong> outbound to Internet, non-system path.</li></ul><h3 id=dfsrsexe><code>dfsrs.exe</code><a href=#dfsrsexe class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Name/role:</strong> <em>DFS Replication</em> service (replicates DFS folders and SYSVOL between DCs).</li><li><strong>Path:</strong> <code>C:\Windows\System32\dfsrs.exe</code> (Service: <code>DFSR</code>).</li><li><strong>Network behavior:</strong> RPC to <strong>partner DCs/servers</strong>, traffic stays inside the domain/site (or site-to-site over private links). No need for Internet peers.</li><li><strong>Proc count:</strong> <strong>1</strong>.</li><li><strong>Red flags:</strong> connections to public IPs, wrong path, odd user, unexpected create time.</li></ul><blockquote><p>heuristic: <strong>DC system processes talk to DCs/clients</strong>; <strong>updaters talk to vendors</strong>; <strong>nothing core should be chatting with random public IPs</strong>.</p></blockquote><p>Funnily enough while I was taking a look at the coreupdater.ex process instance in netscan I noticed that the process extension was cut short to .ex instead of .exe, I later found out that it isn&rsquo;t unheard of for that to happen, couldn&rsquo;t get a straight answer why other than terminal formatting and other reasons but it still caught my eye and so I believed it to be the prime suspect as well as it had an unknown IP that was outside of the LAN.
<img src=coreupdaterinNetscan.png alt=coreupdaterinNetscan class=left></p><p>However I found out that truncated names in netscan/text output often happen because columns get clipped or fixed-width formatting so, not something to look for going forward.</p><h1 id=ioc-check>IoC Check<a href=#ioc-check class=hanchor arialabel=Anchor>#</a></h1><p>Host IP & Port: 10.42.85[.]10:62613
Potentially Malicious process: coreupdater.ex Time: 2020-09-19 03:56:52 UTC
Potential Attacker, Remote IP: 203.78.103.109:443
PID: 3644</p><p>Cross-checked that IP with virus total and got some interesting results stating the IP is malicious.
<img src=VTIoC.png alt=VTIoC class=left></p><p>Given the age of the DFIRMadness writeup there have been many others that have submitted files to virus total by now and the threat we are working with is now very well known so it&rsquo;s no surprise that we are getting immediate hits when looking it up. In a more modern setting many malicious links are new and are not usually reported during investigation (unless you&rsquo;re lucky) so searching it up in VT might not always yield results, something to keep in mind during real-word triaging.</p><h2 id=pstree>PSTree<a href=#pstree class=hanchor arialabel=Anchor>#</a></h2><p><img src=coreupdaterinpstree.png alt=coreupdaterinpstree class=left>
PID:3644
Date 2020-09-19 03:56:37 UTC</p><h2 id=malfindings>Malfindings<a href=#malfindings class=hanchor arialabel=Anchor>#</a></h2><pre><code>Using the malfind volatility plugin
</code></pre><p>In the article he mentions looking for code sandwiches, examples can be found below
<img src=malfindsandwiches.png alt=malfindsandwiches class=left></p><h1 id=ioc-check-1>IoC Check<a href=#ioc-check-1 class=hanchor arialabel=Anchor>#</a></h1><p>Above I also highlighted the potentially malicious process. spoolsv.exe</p><p>Another thing to look for is MZ in the memory Hex and or DOS Mode</p><p>MZ = Portable Executable
READ_WRITE_EXECUTE = No executable can be found on disk, running off of memory, what was in the article read &lsquo;There is no file on disk for this executable code in memory.&rsquo;</p><p>Pro Tip: XOR is a common obfuscation technique and can be seen in the assembly above
<img src=pedetected.png alt=malfipedetectedndsandwiches class=left></p><h2 id=malfind-dump>Malfind Dump<a href=#malfind-dump class=hanchor arialabel=Anchor>#</a></h2><p>We can use malfind to dump processes into a new dir so we can examine the file and run Clam Scan AV against them as well, Clam Scan will help us locate malicious processes. ClamAV is a free and open source antivirus software toolkit. It is really cool and you can learn more about it here <a href=https://www.clamav.net/>https://www.clamav.net/</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vol.py -f citadeldc01.mem --profile=Win2012R2x64 malfind -D /maldump
</span></span></code></pre></div><p>The command above yielded the dmp files below
<img src=maldump.png alt=maldump class=left></p><h2 id=gotcha-1>Gotcha #1<a href=#gotcha-1 class=hanchor arialabel=Anchor>#</a></h2><p>When running the update command</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo freshclam
</span></span></code></pre></div><p>I got an error the log file was locked, meaning the service was running and could not be written while that was the case, hence it could not update, the rest of the commands are shown below
<img src=clamerrorandfix.png alt=clamerrorandfix class=left></p><h2 id=clamscan-findings>ClamScan Findings<a href=#clamscan-findings class=hanchor arialabel=Anchor>#</a></h2><p>Ran Clamscan on the maldump dir I created to store the malfind process dump</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>clamfind -o *
</span></span></code></pre></div><h2 id=findings>Findings<a href=#findings class=hanchor arialabel=Anchor>#</a></h2><img src=calmfindings.png alt=calmfindings class=left><h1 id=meterpreter>Meterpreter<a href=#meterpreter class=hanchor arialabel=Anchor>#</a></h1><p>Appears clamscan found Meterpreter using its scan engine, Meterpreter is a stealthy, in-memory payload used in penetration testing that lets an attacker remotely control a compromised system—running commands, uploading/downloading files, and pivoting—without writing files to disk.</p><p>Created a folder named meterpreter because the infected files appear to have been meterpreter exploits and copied the dump files into that folder
<img src=clammeterpreter.png alt=clammeterpreter class=left></p><h3 id=next-step-is-to-use-fireeyes-floss-fireeye-labs-obfuscated-string-solver>Next Step is to use FireEye&rsquo;s FLOSS FireEye Labs Obfuscated String Solver<a href=#next-step-is-to-use-fireeyes-floss-fireeye-labs-obfuscated-string-solver class=hanchor arialabel=Anchor>#</a></h3><p>FLOSS is an open-source tool that automatically detects, extracts, and decodes obfuscated strings from Windows PE files to speed malware analysis and incident response.<br>It uses advanced static-analysis techniques (including emulation) to recover strings that simple tools miss.<br>Those recovered strings often contain high-value indicators of compromise—malicious domains, IPs, file paths, and configuration data—but analysts still need domain knowledge to interpret the results.</p><h1 id=gotcha-2>Gotcha #2<a href=#gotcha-2 class=hanchor arialabel=Anchor>#</a></h1><p>Given the age of the DFIRMadness post I was following there have been some changes to some of the tools. Floss is now actually &ldquo;flare-floss&rdquo;</p><p>So in order to get it to work I had to do the following:</p><p>Installed it using</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sudo pip install flare-floss
</span></span></code></pre></div><p>added it to PATH</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=s1>&#39;export PATH=&#34;$HOME/.local/bin:$PATH&#34;&#39;</span> <span class=o>&gt;&gt;</span> <span class=o>~/.</span><span class=n>bashrc</span>
</span></span></code></pre></div><p>in the .local&mldr; part ensure the proper path for the file is there
Ran into a few issues when running, at first I Thought it just wouldn&rsquo;t accept a .dmp file because in the GitHub Repo and in the help menu it referenced examples using .exe&rsquo;s
- The reason it was failing was because FLOSS requires the starting bytes to be MZ 0x4d 0x5a? I think, error I got is below
<img src=flosserror.png alt=flosserror class=left></p><p>At the time of this writing however I went back to grab the exact command I ran floss again and did not get the error above instead I got this error
<img src=flosserror2.png alt=flosserror2 class=left>
Thank the mighty penguin for it&rsquo;s easy to read debugger, I re-ran the command using the &ndash;format s64 option and option argument
<img src=flosssuccess.png alt=flosssuccess class=left></p><p>At the end of the output we can find the tcp callback address for the questionable IP we found earlier
flossfindings</p><p>Memory artifacts (malfind dumps + FLOSS strings) indicate shellcode injected into <code>spoolsv.exe</code></p><p>Ran Volatility pstree plugin with the -v argument to get file paths and got the file path for the coreupdater process</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>vol</span><span class=o>.</span><span class=n>py</span> <span class=o>-</span><span class=n>f</span> <span class=n>citadeldc01</span><span class=o>.</span><span class=n>mem</span> <span class=o>--</span><span class=n>profile</span><span class=o>=</span><span class=n>Win2012R2x64</span> <span class=n>pstree</span> <span class=o>-</span><span class=n>v</span> <span class=o>&gt;</span> <span class=n>pstreewpath</span><span class=o>.</span><span class=n>out</span>
</span></span><span class=line><span class=cl><span class=c1># -v displays process path </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>from</span> <span class=n>DFIR</span><span class=p>:</span> <span class=s1>&#39;It will reveal the full path to the image that loaded the process into memory.&#39;</span>
</span></span></code></pre></div><img src=coreupdaterpathviavol.png alt=coreupdaterpathviavol class=left><h1 id=ioc-check-2>IoC Check<a href=#ioc-check-2 class=hanchor arialabel=Anchor>#</a></h1><p>Host IP & Port: 10.42.85.10:62613
Malici0ous process: spoolsv.exe
Potentially Malicious process: coreupdater.ex Time: 2020-09-19 03:56:52 UTC
Potential Attacker, Remote IP: 203.78.103.109:443
PID: 3644</p><h2 id=progress-so-far>Progress So far<a href=#progress-so-far class=hanchor arialabel=Anchor>#</a></h2><ul><li>Used Volatility on the memdump and created output files for various plugins, pstree, pslist, netscan, etc.</li><li>Reviewed netscan for established connections, located a few services, noticed only one reaching out to an external IP that when searched up returned a plethora of malicious indicators.</li><li>Malfind was used to flag <em>and</em> dump memory sections from the processes that it flagged. We dumped these into a directory called maldump.</li><li>From the maldump directory, we used Clam Scan against those objects to find malicious code/infected files and we found Meterpreter</li><li>We made a note of which process was the guilty one by matching the address found in the name with the PID/Address output of malfind</li><li>Then we ran FLOSS against the known infected data objects to find IOC’s like domain names or IP addresses. We found an IP Address.</li><li>We now have a suspicious process that is not normally present on Windows servers communicating with <strong>203.78.103.109</strong> which lived in Thailand around the time of the potential incident.</li><li>We know that process 3724 Spoolsv.exe has Meterpreter injected into it and is now set up to communicate back to the suspicious IP Address, the same address that coreupdater.exe is communicating with.</li><li>Meterpreter can migrate itself from one process to another.</li><li>By looking at the thread count we can tell that one process is inactive and the other is not.</li></ul><p>In the write up James writes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Knowing that times recorded in Memory are not absolutes the following hypothesis emerges: Somehow this coreupdater.exe landed on the system and was communicating to a remote system and is tied to malware on the system. At some point, it injected its malicious code into Spoolsv.exe where it is living now- or was at collection time. This also tells us something else. The original malware had to be at the SYSTEM level. Which on a DC means the attacker likely has the Domains entire list of credentials. This just got ugly.
</span></span></code></pre></div><p>The reason I think he said that is because it appears that Malicious code was injected into spoolsv.exe (Windows Print Spooler Service) which normally runs as the SYSTEM account and code injected into a process inherits that process&rsquo; security token. If <code>spoolsv.exe</code> really was running as <code>NT AUTHORITY\SYSTEM</code>, the injected code would execute with SYSTEM privileges. This is strong circumstantial evidence.</p><h1 id=next-disk-analysis>Next: Disk Analysis<a href=#next-disk-analysis class=hanchor arialabel=Anchor>#</a></h1><p>EWF = Expert Witness File Format, A legally admissible bit for bit copy of target hard drive.</p><h3 id=step-1-mount-ewf-compressed-image>Step 1: Mount EWF Compressed Image<a href=#step-1-mount-ewf-compressed-image class=hanchor arialabel=Anchor>#</a></h3><p>From within ../disk/E01-DC01 directory run the following command ewfmount E01File.E01 /mnt/ewf
<img src=ewfmount.png alt=ewfmount class=left></p><h3 id=step-2-list-partition-layout>Step 2: List Partition Layout<a href=#step-2-list-partition-layout class=hanchor arialabel=Anchor>#</a></h3><p>Use mmls to view the layout of the EWF image</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mmls E01File.E01
</span></span></code></pre></div><img src=mmls.png alt=mmls class=left><h3 id=step-3-mount-the-windows-partition>Step 3: Mount the Windows Partition<a href=#step-3-mount-the-windows-partition class=hanchor arialabel=Anchor>#</a></h3><p>Windows Partition in this case is the first one, with the start byte at 2048 and end at 718847</p><p>To mount this we used the following command</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mount -t ntfs-3g -o loop, ro,show_sys_files,stream_interface=windows,offset=$((2048*512)) /mnt/ewf/ewf1 /mnt/windows_mount
</span></span></code></pre></div><p><img src=mountcommand.png alt=mountcommand class=left>
mount via a loop device, <strong>read only</strong>,show system files, read out ADS (Alternate Data Streams), start the offset at byte number (<strong>2048</strong> sectors of <strong>512</strong> bytes).</p><p>A short explanation for a loop device is essentially a virtual block drive backed by a regular file. Once mounted the kernel redirects read/write requests on /mnt/windows_mount (in this case) back into the file that underlies it&ndash;hence the name &ldquo;loop&rdquo;. It&rsquo;s like a loopback address but in the form of storage.</p><h3 id=step-4-ls-the-files>Step 4: Ls the files<a href=#step-4-ls-the-files class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cd /mnt/windows_mount
</span></span><span class=line><span class=cl>ls /mnt/windows_mount
</span></span></code></pre></div><img src=lsmountedimage.png alt=lsmountedimage class=left><h3 id=step-5-do-it-all-again-with-the-os-partition>Step 5: Do it all again with the OS Partition<a href=#step-5-do-it-all-again-with-the-os-partition class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sudo umount /mnt/windows_mount
</span></span></code></pre></div><img src=umount.png alt=umount class=left><h2 id=on-the-os-partition>On the OS Partition<a href=#on-the-os-partition class=hanchor arialabel=Anchor>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mount -t ntfs-3g -o loop, ro,show_sys_files,stream_interface=windows,offset=$((718848*512)) /mnt/ewf/ewf1 /mnt/windows_mount
</span></span></code></pre></div><img src=mountOSpartition.png alt=mountOSpartition class=left><p>Took a look around found some interesting items</p><h3 id=enumerate-users-on-dc>Enumerate Users on DC<a href=#enumerate-users-on-dc class=hanchor arialabel=Anchor>#</a></h3><img src=dcusers.png alt=dcusers class=left><h3 id=administrator-is-a-user-of-interest>Administrator is a user of interest<a href=#administrator-is-a-user-of-interest class=hanchor arialabel=Anchor>#</a></h3><p>Checked Contents of Administrator
<img src=Admincontents.png alt=Admincontents class=left></p><p>Found Interesting Artifacts in &ldquo;Recents&rdquo;
Recents folder contains .lnk files of files and/or folders that have been recently opened. It is isn&rsquo;t an end all be all type of finding but by using &ldquo;strings&rdquo; or &ldquo;exiftool&rdquo; to extract legible strings or metadata we can learn more about the recent files most importantly where they are located.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># -e = encoding type to look for -l = 16-bit little-endian (UTF-16LE)
</span></span><span class=line><span class=cl>strings -el Beth_Secret.lnk 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># You can also run it without the -el option, I will show both outputs below, I prefer without the -el
</span></span></code></pre></div><img src=stringsBethSecret.png alt=stringsBethSecret class=left><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>exiftool</span> <span class=n>Beth_Secret</span><span class=o>.</span><span class=n>lnk</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># exiftool is awesome because it provides all metadata including Create, Access and Modify Date. But since this is a .lnk file it’s really showing the shortcut’s own timestamps (and any snapshot of the target file’s times recorded when the link was made), not the current live access time of the target file.</span>
</span></span></code></pre></div><img src=exiftoolBethSecrets.png alt=exiftoolBethSecrets class=left><p>Checked that directory for it&rsquo;s contents
<img src=lssecretfileshare.png alt=lssecretfileshare class=left></p><p>There&rsquo;s the Szechuan sauce file! along with a few other assumed secrets, hence the &ldquo;secret&rdquo; folder</p><p>Not much else I can find from here, Moved on to extracting the Registry Hives of Interest such as SYSTEM & SOFTWARE</p><p>In the article he mentions drag and drop between VMs, I&rsquo;m not sure how to make that work, it was not working for me so I just ran a simple http server from the sift workstation using</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>simple python http server running off port 8080 from current directory
</span></span><span class=line><span class=cl>python -m http.server 8080
</span></span></code></pre></div><p>To get the most accurate picture of the SYSTEM hive, the hive logs are required for proper analysis. Without the logs, the data will be incomplete and insufficient.</p><p>I used the following command to create a zip file with the SYSTEM Reg Hive</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># the -e is to password protect the file
</span></span><span class=line><span class=cl>zip -e reghives.zip /mnt/windows_mount/Windows/System32/config/SYSTEM* 
</span></span></code></pre></div><p>Started the http server from the zip file directory
<img src=hivezip.png alt=hivezip class=left></p><p>Used wget from W10 VM (To Be safe I&rsquo;d rather , and I&rsquo;d recommend anyone not transfer potentially malicious artifacts into anything other than a sandbox/vm)
<img src=wget.png alt=wget class=left></p><p>I can confirm the GET was also received on the SIFT workstation end
<img src=getconfirm.png alt=getconfirm class=left></p><h2 id=registry-explorer>Registry Explorer<a href=#registry-explorer class=hanchor arialabel=Anchor>#</a></h2><p>Opened up Reg Explorer on my Win10 VM > Extracted reghives.zip > Opened Hive in Reg explorer and began by checking:</p><h3 id=timezone>TimeZone<a href=#timezone class=hanchor arialabel=Anchor>#</a></h3><p><img src=regexplorer.png alt=regexplorer class=left>
Appears they are on Pacific Standard time</p><h3 id=computer-name>Computer name<a href=#computer-name class=hanchor arialabel=Anchor>#</a></h3><p><img src=regexplorer2.png alt=regexplorer2 class=left>
DC Hostname = CITADEL-DC01</p><h2 id=network-shares>Network Shares<a href=#network-shares class=hanchor arialabel=Anchor>#</a></h2><img src=regexplorer3.png alt=regexplorer3 class=left><p>Fileshare on DC is the one we saw earlier &ldquo;Fileshare&rdquo;</p><h2 id=coreupdater>Coreupdater<a href=#coreupdater class=hanchor arialabel=Anchor>#</a></h2><img src=regexplorer4.png alt=regexplorer4 class=left><p>Searched up Coreupdater and found it under services, within System32 folder..</p><h2 id=autoruns>Autoruns<a href=#autoruns class=hanchor arialabel=Anchor>#</a></h2><p>During an incident from the USB drive the following command can be ran
<code>.\autorunsc64.exe -accepteula -a * -s -h -c > .\autoruns-citadeldc01.csv</code></p><p>I opened the CSV in Timeline Explorer and triaged the usual hiding spots (Run keys, Services, Scheduled Tasks, hijacks) by filtering for <strong>Enabled</strong> + <strong>Unsigned</strong> entries.</p><p><strong>Findings (two pivots):</strong></p><ol><li><p><strong>Registry Run key → hidden PowerShell loader</strong><br><code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\coreupdate</code> launched PowerShell with a command that referenced <code>HKLM:\Software\9sEoCawv</code>. The value was nested <strong>Base64 → UTF-16 → Base64 (GZIP)</strong> that decoded to a script starting a hidden 64-bit PowerShell and executing <strong>in-memory shellcode</strong> (<code>VirtualAlloc</code> → copy bytes → <code>CreateThread</code> → <code>WaitForSingleObject</code>). Capa on the decoded blob showed loader behavior consistent with <strong>file-less execution</strong>.<br><em>(Screenshots to keep: registry key hit; CyberChef decode; capa snippet.)</em></p></li><li><p><strong>Service → suspicious binary in System32</strong><br><code>coreupdater.exe</code> registered as a <strong>service</strong> and lived in <strong>C:\Windows\System32</strong> but was <strong>unsigned</strong>. On a DC, that’s a red flag and implies privileged write access. Detonation in Joe Sandbox identified it as a <strong>Meterpreter</strong> payload with C2 <strong>203.78.103.109</strong>.<br><em>(Screenshots to keep: “Enabled & Unsigned” filter; sandbox IOC/MITRE panels.)</em></p></li></ol><p><strong>Why it matters:</strong><br>We have two persistence mechanisms: (a) a registry-based PowerShell loader that runs shellcode from memory, and (b) a System32 service binary calling out to the same adversary infrastructure seen elsewhere in the case. Together they point to <strong>elevated access and long-term persistence</strong> on the DC</p><h2 id=pcap-analysis-with-snort-tcpdump--wireshark>Pcap Analysis with Snort, Tcpdump & Wireshark<a href=#pcap-analysis-with-snort-tcpdump--wireshark class=hanchor arialabel=Anchor>#</a></h2><p>In DFIR he used tcpdump, it was fun to follow along and I learned a lot but I wanted to take this opportunity to learn more about wireshark so with the help of Chris Greer I learned quite a bit, check out his channel <a href=https://www.youtube.com/@ChrisGreer>here</a></p><p>I started by installing Snort and pointing its <code>HOME_NET</code> to the target subnet:</p><p><code>sudo snap install snort sudo nano /etc/snort/snort.debian.conf # set HOME_NET 10.42.85.0/24</code></p><p>If you don’t know the subnet ahead of time you can confirm it from the pcap with:</p><p><code>sudo tcpdump -nr case001.pcap 'host 10.42' -c15</code></p><img src=pcap.png alt=pcap class=left><p>To be able to find the Snort config quickly later I installed <code>locate</code> and updated its DB.<br>Tested the configuration:</p><p><code>snort -c /etc/snort/snort.conf -T -i lo</code></p><img src=snortconftest.png alt=snortconftest class=left><hr><h3 id=reducing-the-noise>Reducing the Noise<a href=#reducing-the-noise class=hanchor arialabel=Anchor>#</a></h3><p>The pcap had ~412 k packets (<code>capinfos case001.pcap</code>)
<img src=capinfos.png alt=capinfos class=left>
so I ran Snort in offline mode, only alerting to console and saving to a text file:</p><p><code>sudo snort -c /etc/snort/snort.conf -r case001.pcap -q -K none -A console | tee snort.out wc -l snort.out # only a few hundred alerts</code></p><img src=snort2.png alt=snort2 class=left><p>Right away Snort flagged brute-force RDP from <strong>194.61.24.102</strong> to <strong>10.42.85.10</strong>, followed by lateral RDP moves inside the subnet.</p><p><img src=snort3.png alt=snort3 class=left><br><img src=snort4.png alt=snort4 class=left></p><p>A quick tcpdump filter confirmed an Nmap scan from the same IP:</p><p><img src=nmap.png alt=nmap class=left>
<code>Grabbed image above from DFIR, did not get to grab from my terminal</code>
This gave us two key external IOCs: <strong>194.61.24.102</strong> (initial access) and <strong>203.78.103.109</strong> (later C2).</p><hr><h3 id=mapping-connections>Mapping Connections<a href=#mapping-connections class=hanchor arialabel=Anchor>#</a></h3><p>To quantify internal ↔ external traffic I used tcpdump with SYN-flag filters:</p><p><code># internal hosts reaching out tcpdump -nttttr case001.pcap 'tcp[13]&amp;0x3f=0x02 and src net 10.42.85.0/24 and not dst net 10.42.85.0/24' \ | awk '{print $6}' | cut -d. -f1-4 | sort | uniq -c | sort -nr</code></p><img src=tcpdump.png alt=tcpdump class=left><p><code># external hosts initiating to internal tcpdump -nttttr case001.pcap 'tcp[13]&amp;0x3f=0x02 and dst net 10.42.85.0/24' \ | awk '{print $4}' | cut -d. -f1-4 | sort | uniq -c | sort -nr</code></p><img src=tcpdump2.png alt=tcpdump2 class=left><p>These showed ~29 k inbound SYNs and ~23 k outbound SYNs.<br>Internal RDP conversations (port 3389) were isolated the same way:</p><p><code>tcpdump -nttttr case001.pcap 'tcp port 3389 and src net 10.42.85.0/24 and dst net 10.42.85.0/24' -c15</code></p><img src=tcpdump3.png alt=tcpdump3 class=left><hr><h3 id=pulling-the-malware>Pulling the Malware<a href=#pulling-the-malware class=hanchor arialabel=Anchor>#</a></h3><p>Using Wireshark search (<code>coreupdater.ex</code>) and “Follow TCP Stream” between 194.61.24.102 and the DC, I found a simple Python HTTP server delivering <strong>coreupdater.exe</strong>.</p><img src=wireshark.png alt=wireshark class=left><p>I exported that object from the capture, hashed it</p><p><code>sha256sum coreupdater.exe # 10f3b92002bb98467334161cf85d0b1730851f9256f83c27db125e9a0c1cfda6</code></p><p>and confirmed on VirusTotal that it’s malware.<br>Joe Sandbox further identified it as a <strong>Meterpreter</strong> payload with C2 at <strong>203.78.103.109</strong>.</p><img src=mitre.png alt=mitre class=left><hr><h3 id=quick-takeaways>Quick Takeaways<a href=#quick-takeaways class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Initial access:</strong> 194.61.24.102 brute-forced RDP to 10.42.85.10 (Domain Controller).</li><li><strong>Lateral movement:</strong> Same IP pivoted to another internal host via RDP.</li><li><strong>Payload delivery:</strong> coreupdater.exe served over plain HTTP from 194.61.24.102.</li><li><strong>Command & Control:</strong> coreupdater.exe called back to 203.78.103.109 (Thailand).</li><li><strong>Persistence link:</strong> the same binary appears later in disk and autoruns artifacts.</li></ul><hr><p><strong>Key IOCs to carry forward</strong><br><code>coreupdater.exe</code> - SHA256: <code>10f3b92002bb98467334161cf85d0b1730851f9256f83c27db125e9a0c1cfda6</code><br>IPs: <strong>194.61.24.102</strong>, <strong>203.78.103.109</strong></p><p>This phase tied network activity to the malware found elsewhere in the case and showed exactly how it entered and spread inside the network.</p><p>Next&mldr; Sleuth kit FLS & Timeline Generation</p><h2 id=fls-filename-layer-tools>FLS (Filename Layer Tools)<a href=#fls-filename-layer-tools class=hanchor arialabel=Anchor>#</a></h2><blockquote><p>From DFIR:
&ldquo;FLS is used to extract a <em>quick picture</em> of the history the Operating System via the disk image. The FLS tool is run against each partition of the disk image and the results are placed into body file. That body file is processed by the program <code>mactime</code> and output to a CSV. If we spend 5 additional minutes we greatly enhance the resultant CSV by adding the timeline of data that was resident in memory at the time of capture. Many events relevant to an investigation live in the memory of the victim machine.&rdquo;</p><p>Volatility has a cool plugin named timeliner that will parse memory images for interesting events with timestamps and will output it to a body file.</p><p>Image files = forensic image, sector by sector copy of a storage medium.
Body files = structured tab delimited text file that lists file or artifact timestamps (MAC Times, etc) and metadata, it&rsquo;s a timeline database, the output will be a CSV file</p><p>So we can use FLS to enumerate a disk image and produce a body file of file-system timestamps, Volatility&rsquo;s timeliner will parse data from memory and also place it in a body file of file stamped memory artifacts, then we combine the body files which can then be fed into mactime which generates a unified CSV timeline for investigation.</p></blockquote><p>Diagram from <a href=https://dfirmadness.com/triage-disk-analysis-case-001/>DFIR</a> below
<img src=flsdfir.png alt=flsdfir class=left></p><h2 id=running-fls>Running FLS<a href=#running-fls class=hanchor arialabel=Anchor>#</a></h2><p>FLS requires the start byte value for each partition. The start byte can be found using mmls that we used earlier.</p><p>Commands for FLS in this case are below</p><p>First Partition</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fls -m -r -o 2048 /mnt/ewf/ewf1 &gt; fls-drive-dc01.body
</span></span></code></pre></div><img src=fls.png alt=fls class=left><p>Second Partition</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fls -m -r -o 718848 /mnt/ewf/ewf1 &gt;&gt; fls-drive-dc01.body
</span></span></code></pre></div><p>Reminder to use sudo or to run as root incase you get permission denied such as I did below
<img src=fls2.png alt=fls2 class=left></p><p>At this point we have carved 2 body files, 1 per partition</p><p>Next the memory body file</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vol.py -f citadeldc01.mem --profile=Win2012R2x64 timeliner --output=body --output-file=mem
</span></span></code></pre></div><img src=volmem.png alt=volmem class=left><p>Create backups of the image body files just in case something breaks after appending the mem body file</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cp fls-drive-dc01.body fls-drive-dc01.body.bak
</span></span></code></pre></div><p>Ended up with the files below
<img src=bodyfilesls.png alt=bodyfilesls class=left></p><p>Lastly, merge the mem timeline with the image timeline body file
<img src=bodymerge.png alt=bodymerge class=left></p><h2 id=its-mactime>It&rsquo;s Mactime!<a href=#its-mactime class=hanchor arialabel=Anchor>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># -y=Use ISO-8601 date format in output -d=CSV Output -z=TimeZone -b= looks for 
</span></span><span class=line><span class=cl># input file, in this case it is fls-drive-dc01.body
</span></span><span class=line><span class=cl>`mactime -y -d -z UTC -b fls-drive-dc01.body &gt; dc01-fls.csv`
</span></span></code></pre></div><img src=mactime1.png alt=mactime1 class=left><p>Towards the beginning of the combined timeline CSV, most rows come from the Volatility timeliner memory body file. These records describe processes and other in-memory artifacts and typically lack traditional MACB timestamps, so the date/time fields may show as <code>0000-00-00T00:00:00Z</code>. They are still valuable for identifying what was active in memory.</p><img src=csvcombined1.png alt=csvcombined1 class=left><p>Towards the tail end we start to see disk-based events contributed by the Sleuth Kit body file (from <code>fls</code>). These entries correspond to actual file-system objects and therefore include valid MACB timestamps (Modified, Accessed, Changed, Birth/Created), providing concrete temporal context.</p><p>In DFIR he gives 3 options to view the CSV. LibreOffice, Microsoft Excel or Eric Zimmerman&rsquo;s TimelineExplorer. I tried LibreOffice and realized I made a mistake and should&rsquo;ve gone with EZ&rsquo;s TE from the get go. It&rsquo;s awesome.</p><h2 id=ioc-remindercheck>IoC Reminder/Check<a href=#ioc-remindercheck class=hanchor arialabel=Anchor>#</a></h2><p>Host IP & Port: 10.42.85.10:62613
Malicious process: spoolsv.exe
Potentially Malicious process: coreupdater.exe Time: 2020-09-19 03:56:52 UTC
Potential Attacker, Remote IP: 203.78.103.109:443
PID: 3644</p><h2 id=dc01timelinecsv>dc01timeline.csv<a href=#dc01timelinecsv class=hanchor arialabel=Anchor>#</a></h2><pre><code>&quot;Coreupdater&quot; search results
</code></pre><img src=coreupdtsrchrslts.png alt=coreupdtsrchrslts class=left><h2 id=creating-supertimeline>Creating SuperTimeline<a href=#creating-supertimeline class=hanchor arialabel=Anchor>#</a></h2><p>From DFIR</p><blockquote><p>&ldquo;Super timelines are made up of many different data sources found on a systems disk and in it’s memory. Investigators can use tools like “Log2Timeline.py” to process a disk image and collect vast amounts of data for the timeline. Sources of data include the registry, system logs, and much more. All of these data points are placed into an SQLite database called a dump file. Volatility is also able to take time stamped events from memory images and add those to a body file. This body file is then processed by Log2timeline using the “mactime” parser. The Log2timeline “mactime” parser extracts timestamped events from the memory body file and places them into the dump file. Finally, Psort processes the dump file into a CSV file that can easily be examined using Eric Zimmerman’s Timeline Explorer or Excel. This process is illustrated later on in this section.</p><p>The best way to approach super timeline creation is to kick it off almost immediately after collecting the hard drive, and having obtained an <a href=https://dfirmadness.com/triage-disk-analysis-case-001/>FLS collection of the drive</a>. Super timeline processing can take many <strong>hours</strong> for large server drives. That won’t be the case for this lab, but in reality it can easily take hours. The best approach is for investigators to have the super timeline processing in the background as they tackle other tasks such as <a href=https://dfirmadness.com/case-001-memory-analysis/>memory analysis</a>.&rdquo;</p></blockquote><img src=dfirsupertimeline.png alt=dfirsupertimeline class=left><h2 id=tools-used-in-this-section-and-brief-descriptions>Tools used in this section and brief descriptions<a href=#tools-used-in-this-section-and-brief-descriptions class=hanchor arialabel=Anchor>#</a></h2><h3 id=pinfopy>Pinfo.py<a href=#pinfopy class=hanchor arialabel=Anchor>#</a></h3><p>Plaso Info is a tool that returns information about a plaso dump file.</p><h3 id=psortpy>Psort.py<a href=#psortpy class=hanchor arialabel=Anchor>#</a></h3><p>Plaso sort processes the plaso dump file. The most common file type to process the data into is a CSV.</p><h3 id=pstealpy>PSteal.py<a href=#pstealpy class=hanchor arialabel=Anchor>#</a></h3><p>Combining Log2timeline and Psort into one action for a quick slice of the image. This will not be demonstrated in this lab.</p><h3 id=image_exportpy>Image_Export.py<a href=#image_exportpy class=hanchor arialabel=Anchor>#</a></h3><p>From the help header:</p><blockquote><p>This is a simple collector designed to export files inside an image, both within a regular RAW image as well as inside a VSS. The tool uses a collection filter that uses the same syntax as a targeted plaso filter.</p></blockquote><h2 id=supertimeline-process>SuperTimeline Process<a href=#supertimeline-process class=hanchor arialabel=Anchor>#</a></h2><ol><li>Process memory image with Volatility Timeliner, Shellbags, and MFT modules into 1 memory timeline</li><li>Process the E01 Image with log2timeline into a plaso dmp file</li><li>Combine the mem body file with the plaso dmp file</li><li>Sort the data with psort into a CSV</li></ol><h3 id=creating-mem-body-file-using-volatility2>Creating Mem Body File using volatility2<a href=#creating-mem-body-file-using-volatility2 class=hanchor arialabel=Anchor>#</a></h3><pre><code>$ vol.py -f citadeldc01.mem --profile=Win2012R2x64 timeliner --output=body --output-file=./dc01-super-time.body
$ vol.py -f citadeldc01.mem --profile=Win2012R2x64 shellbags --output=body --output-file=./dc01-shell-bags.body
$ vol.py -f citadeldc01.mem --profile=Win2012R2x64 mftparser --output=body --output-file=./dc01mft.body
</code></pre><img src=membodyfile.png alt=membodyfile class=left><h3 id=creating-light-targeted-timeline>Creating light targeted Timeline<a href=#creating-light-targeted-timeline class=hanchor arialabel=Anchor>#</a></h3><pre><code>$ log2timeline.py --status_view window -f /usr/share/plaso/filter_windows.yaml --storage_file dc01triage.dump ../disk/E01-DC01/20200918_0347_CDrive.E01 --partitions all

$ log2timeline.py --parsers=&quot;mactime&quot; --status_view window --storage_file dc01triage.dump ./dc01-super-time.body
</code></pre><h3 id=creating-targeted-timeline>Creating Targeted Timeline<a href=#creating-targeted-timeline class=hanchor arialabel=Anchor>#</a></h3><pre><code>log2timeline.py --parsers=&quot;winevtx,usnjrnl,prefetch,winreg,esedb/srum&quot; --status_view window --storage_file dc01targeted.dump ../disk/E01-DC01/20200918_0347_CDrive.E01 --partitions &quot;all&quot;

$ log2timeline.py --parsers=&quot;mactime&quot; --status_view window --storage_file dc01targeted.dump ./dc01-super-time.body
</code></pre><h3 id=superdump-lol>SuperDump lol!<a href=#superdump-lol class=hanchor arialabel=Anchor>#</a></h3><pre><code>log2timeline.py --parsers=&quot;winevtx,mft,prefetch,esedb,win_gen,winreg,olecf/olecf_automatic_destinations&quot; --status_view window --storage_file dc01super.dump ../disk/E01-DC01/20200918_0347_CDrive.E01 --partitions &quot;all&quot;

$ log2timeline.py --parsers=&quot;mactime&quot; --status_view window --storage_file dc01super.dump ./dc01-super-time.body
</code></pre><h2 id=supertimeline>SuperTimeLine!<a href=#supertimeline class=hanchor arialabel=Anchor>#</a></h2><p><strong><em>Recommended Method</em>:</strong> Analysts that want a CSV with the <strong>times adjusted to match the correct time (same as the network time)</strong> can use the following command:</p><p><code>psort.py dc01super.dump --output_time_zone "Atlantic/Cape_Verde" -o L2tcsv -w dc01-superduper-timeline.csv</code></p><p>The following command will generate a super timeline from the dc01-super.dump dump file created with UTC as the time zone:</p><p><code>psort.py dc01super.dump --output_time_zone "UTC" -o L2tcsv -w dc01-superduper-timeline.csv</code></p><h2 id=supertimeline-findings>SuperTimeline Findings<a href=#supertimeline-findings class=hanchor arialabel=Anchor>#</a></h2><h2 id=ioc-remindercheck-1>IoC Reminder/Check<a href=#ioc-remindercheck-1 class=hanchor arialabel=Anchor>#</a></h2><p>Host IP & Port: 10.42.85.10:62613
Malicious process: spoolsv.exe
Potentially Malicious process: coreupdater.exe Time: 2020-09-19 03:56:52 UTC
Potential Attacker, Remote IPs: 203.78.103.109:443 & 194.61.24.102
PID: 3644</p><h3 id=coreupdater-search-results-and-findings>Coreupdater search results and findings<a href=#coreupdater-search-results-and-findings class=hanchor arialabel=Anchor>#</a></h3><p>Got a few hits
<img src=coreupdtrsrchrslts2.png alt=coreupdtrsrchrslts2 class=left></p><p>In the first line I noticed that coreupdater has a timestamp of 2010-04-14 22:06:53 and I was confused
<img src=timestamp1.png alt=timestamp1 class=left>
<img src=coreupdtr3.png alt=coreupdtr3 class=left></p><p>Turns out this is actually the &ldquo;compile&rdquo; time from the EXE&rsquo;s header. It&rsquo;s not when it first hit the system. Windows binaries from Win7 era often have April 2010 dates. Though the weird thing is I can&rsquo;t find any reputable &ldquo;coreupdater&rdquo; online so&mldr; I guess that remains to be verified.</p><p>PE = Portable Executable
COFF = Common Object File Format
Together that&rsquo;s the Windows standard EXE/DLL format</p><p>&ldquo;There&rsquo;s a PE executable called coreupdater.exe. It was compiled on April 14th 2010 and lives in System32. Here&rsquo;s its unique NTFS record (87137) and import hash&rdquo;</p><p>Moving on..
2nd line (don&rsquo;t worry we&rsquo;re only doing a few for understanding (I was talking to myself there))</p><pre><code>Timestamp	Source Description	Source Name	macb	Inode	
2020-09-19 03:24:06	Bodyfile	FILE	m...	87137	
</code></pre><p>Long Description
[MFT FILE_NAME] Windows\System32\coreupdater.exe (Offset: 0x2cc50400) Owner identifier: 0 Group identifier: 0 Mode: &mdash;a&mdash;&mdash;&mdash;&ndash;</p><p>Owner Identifier: 0 = Absence of a defined security identifier
macb: m = modified, how? &ldquo;File name?&rdquo;
Offset = the byte offset inside the MFT where that record sits</p><p>&ldquo;NTFS updated the name record for coreupdater.exe&rdquo;</p><h3 id=3rd-line-first-macb-entry-for-coreupdaterexe><strong>3rd line (First MACB entry for coreupdater.exe)</strong><a href=#3rd-line-first-macb-entry-for-coreupdaterexe class=hanchor arialabel=Anchor>#</a></h3><pre><code>Timestamp	Source Description	Source Name	macb	Inode	
2020-09-19 03:24:06	Bodyfile	FILE	macb	76711	
</code></pre><p>Long Description
[MFT FILE_NAME] Users\Administrator\AppData\Local\Microsoft\Feeds{5588ACFD-6436-411B-A5CE-666AE6A92D3D}<del>\WebSlices</del>\coreupdater[1].exe (Offset: 0x3209f288) Owner identifier: 0 Group identifier: 0 Mode: &mdash;a&mdash;&mdash;-I&mdash;</p><p>Path: Feeds{GUID}\Webslices
&ldquo;Webslices&rdquo; was an IE feature for live-updating pieces of a webpage. It has its own cache under AppData
MACB: m.a.c.b = Modified, Accessed, metadata Changed, Birth &ndash; First instance of this file, all MACB indicators were set.
I flag in the mode = file is indexed by NTFS indexing service
The [1] usually means it&rsquo;s a duplicate of something already named coreupdater.exe</p><p>4th & 5th line</p><pre><code>Timestamp	          Source Description Source Name	macb	Inode	
2020-09-19 03:24:06	NTFS USN change	     FILE      	..c.	84656	
</code></pre><p>Long Description
coreupdater[1].exe File reference: 76711-12 Parent file reference: 87050-1 Update source: Update reason: USN_REASON_DATA_EXTEND USN_REASON_FILE_CREATE</p><pre><code>Timestamp	          Source Description Source Name    macb	Inode	
2020-09-19 03:24:06	NTFS USN change	    FILE	    ..c.	84656	
</code></pre><p>Long Description
coreupdater[1].exe File reference: 76711-12 Parent file reference: 87050-1 Update source: Update reason: USN_REASON_FILE_CREATE</p><p>USN= Update Sequence Number journal &ndash; NTFS&rsquo;s built-in change log
MACB: ..c. only metadata Changed
USN_REASON_FILE_CREATE – NTFS logged that the file was created.
USN_REASON_DATA_EXTEND – file size grew because data was written</p><p>&ldquo;Change journal logged the creation of coreupdater[1] and noted that its data was written.&rdquo;</p><h2 id=dc-csv-findings>DC CSV Findings<a href=#dc-csv-findings class=hanchor arialabel=Anchor>#</a></h2><p>Timestamps look different in the following entries as I was parsing a second supertimeline file.
After reviewing the .CSV under the &ldquo;coreupdater&rdquo; search results this is what I found</p><ul><li><p>A binary <strong>compiled in 2010</strong> (<code>coreupdater.exe</code>) was <strong>downloaded via IE/Edge WebSlices cache</strong> as <code>coreupdater[1].exe</code> at <strong>02:24:06</strong>.</p></li><li><p>The browser created a <code>.partial</code> file, repeatedly <strong>extended, truncated, and closed it</strong> as the download progressed.</p></li><li><p>Within seconds, the file was <strong>renamed and moved</strong> from the WebSlices cache to <code>C:\Windows\System32\coreupdater.exe</code>.</p></li><li><p>At <strong>02:24:50</strong>, NTFS logged a <strong>security change and final rename</strong>, indicating the file was settled in System32 with its final ACLs.</p></li><li><p>At <strong>02:27:49</strong>, the malware <strong>installed itself as a Windows service</strong> (<code>coreupdater</code>), configured to <strong>auto-start</strong>.</p></li><li><p>By <strong>02:56:37</strong>, the executable <strong>spawned a process (PID 3644)</strong>, with registry/UserAssist entries confirming <strong>execution</strong> and <strong>multiple launches</strong>.</p><h3 id=1946124102-search-results>194.61.24.102 Search Results<a href=#1946124102-search-results class=hanchor arialabel=Anchor>#</a></h3><pre><code>Timestamp	Source     Description Source Name	macb	Inode	
  2020-09-19 02:21:47	WinEVTX	     EVT	    m..b	     467	
</code></pre></li></ul><p>Long Description
[1149 / 0x047d] Provider identifier: {c76baa63-ae81-421c-b425-340b4b24157f} Source Name: Microsoft-Windows-TerminalServices-RemoteConnectionManager Strings: [&lsquo;Administrator&rsquo; &rsquo;&rsquo; &lsquo;194.61.24.102&rsquo;] Computer Name: CITADEL-DC01.C137.local Record Number: 29322 Event Level: 4 Message string: Remote Desktop Services: <strong>User authentication succeeded</strong>:\n\nUser: Administrator\nDomain: \nSource Network Address: 194.61.24.102
<img src=IoC1.png alt=IoC1 class=left></p><p>Looks like Attacker gained access at 02:21:47 after a series of brute force attempts. Which we already knew.</p><p>Maybe they logged off at 02:28:41</p><pre><code>Timestamp	         Source Description	Source Name	macb	Inode	
2020-09-19 02:28:41	WinEVTX	             EVT	m..b	84706	
</code></pre><p>Long Description
[4634 / 0x121a] Provider identifier: {54849625-5478-4994-a5ba-3e3b0328c30d} Source Name: Microsoft-Windows-Security-Auditing Strings: [&lsquo;S-1-5-18&rsquo; &lsquo;CITADEL-DC01$&rsquo; &lsquo;C137&rsquo; &lsquo;0x00000000005576b0&rsquo; &lsquo;3&rsquo;] Computer Name: CITADEL-DC01.C137.local Record Number: 7626 Event Level: 0 Message string: <strong>An account was logged off</strong>.\n\nSubject:\n\tSecurity ID:\t\tS-1-5-18\n\tAccount Name:\t\tCITADEL-DC01$\n\tAccount Domain:\t\tC137\n\tLogon ID:\t\t0x00000000005576b0\n\nLogon Type:\t\t\t3\n\nThis event is generated when a logon session is destroyed. It may be positively correlated with a logon event using the Logon ID value. Logon IDs are only unique between reboots on the same computer.</p><p>Noticed Lateral Movement attempt to DESKTOP-SDN1RPT at 2020-09-19 03:35:54, meaning they did not log off at 03:28:41
Long Description
[1024 / 0x0400] Provider identifier: {28aa95bb-d444-4719-a36f-40462168127e} Source Name: Microsoft-Windows-TerminalServices-ClientActiveXCore Strings: [&lsquo;Server Name&rsquo; &lsquo;DESKTOP-SDN1RPT&rsquo; &lsquo;Info&rsquo;] Computer Name: CITADEL-DC01.C137.local Record Number: 1 Event Level: 4 Message string: RDP ClientActiveX is trying to connect to the server (DESKTOP-SDN1RPT)</p><p>Reviewed Wireshark a bit more
Confirmed Lateral Movement time at 02:35:55
<img src=wiresharkioc.png alt=wiresharkioc class=left></p><p>End of session between DC and Workstation at 02:52:14
<img src=wiresharkioc2.png alt=wiresharkioc2 class=left></p><h2 id=fileshare-contents>FileShare Contents<a href=#fileshare-contents class=hanchor arialabel=Anchor>#</a></h2><p>Out of all the searches for the files within the Fileshare\Secrets directory I noticed something off about the events surrounding Beth_Secret.txt, I noticed it was renamed here</p><p>Timestamp<br>2020-09-18 21:39:21
Long Description
SECRET_beth.txt File reference: 73635-13 Parent file reference: 86966-9 Update source: Update reason: USN_REASON_RENAME_NEW_NAME
Used to be named SECRET_Beth.txt but is now named Beth_Secret.txt
It also appears it was deleted after it was extracted in a zip file
<img src=IoC2.png alt=IoC2 class=left>
<img src=IoC3.png alt=IoC3 class=left></p><p>When I checked the file in the Recycling Bin I noticed the contents are different from the file that was left on the server.</p><p>Beth_Secret.txt (New File)
<img src=secretbeth1.png alt=secretbeth1 class=left></p><p>Secret_Beth.txt (Original)
<img src=secretbeth2.png alt=secretbeth2 class=left></p><p>I also checked metadata and noticed that it had a date prior to when the file was created given that the creation date per the macb timestamps in the timeline log indicate that it was created here Timestamp 2020-09-19 02:34:56
<img src=timestamp.png alt=timestamp class=left></p><p>But Exiftool metadata gives is a Modified and Accessed date of a day before? Time stomped?
<img src=exiftoolbethsecret.png alt=exiftoolbethsecret class=left></p><h3 id=summary-thus-far>Summary thus far<a href=#summary-thus-far class=hanchor arialabel=Anchor>#</a></h3><p>The attacker gained access to the domain controller (DC) after a series of <strong>brute-force RDP (Remote Desktop Protocol)</strong> attempts.</p><p>Attacker deployed a <strong>Metasploit Meterpreter payload</strong> packaged in <code>coreupdater.exe</code>, which was <strong>delivered via a malicious WebSlices download</strong>.</p><p>During execution, the malware <strong>persisted as an auto-start Windows service</strong> and Memory artifacts (malfind dumps + FLOSS strings) indicate shellcode injected into <code>spoolsv.exe``, allowing it to operate with </code>NT AUTHORITY\SYSTEM` privileges.</p><p>To cover their tracks and tamper with data, the attacker <strong>replaced <code>Secret_Beth.txt</code> with a modified file <code>Beth_Secret.txt</code></strong> after collecting the contents of the <code>Fileshare\Secrets</code> directory in a ZIP file named <code>Secret.zip</code>.<br>Finally, using the compromised <strong>Administrator credentials</strong>, the attacker performed <strong>lateral movement over RDP to the workstation 10.42.85.115</strong>.<br>I learned a great deal during this investigation. I have not yet completed a deep dive into the workstation evidence and may publish a follow-up with those findings.</p><h2 id=lastly-answers-to-the-questions-on-dfirmadness-below>Lastly, Answers to the Questions on DFIRMadness below<a href=#lastly-answers-to-the-questions-on-dfirmadness-below class=hanchor arialabel=Anchor>#</a></h2><ol><li><p>What’s the Operating System of the Server?
Windows 2012 R2</p></li><li><p>What’s the Operating System of the Desktop?
Windows 10 Enterprise Evaluation
<img src=desktopOS.png alt=desktopOS class=left></p></li><li><p>What was the local time of the Server?
<img src=servertimezone.png alt=servertimezone class=left></p></li><li><p>Was there a breach?
Yes</p></li><li><p>What was the initial entry vector (how did they get in)?
Brute force attempt from a kali machine using the administrator account</p></li><li><p>Was malware used? If so what was it? If there was malware answer the following:</p><ol><li>What process was malicious?
coreupdater.exe & spoolsv</li><li>Identify the IP Address that delivered the payload.
194.61.24[.]102</li><li>What IP Address is the malware calling to?
203.78.103[.]109</li><li>Where is this malware on disk?
System32</li><li>When did it first appear?
02:24:06</li><li>Did someone move it?
Yes from the Webslices/Downloads cache to C:\Windows\System32</li><li>What were the capabilities of this malware?
Being that it was metasploit it likely is very versatile</li><li>Is this malware easily obtained?
Yes</li><li>Was this malware installed with persistence on any machine?
Yes<ol><li>When?
02:27:49</li><li>Where?
HKEY_LOCAL_MACHINE\System\ControlSet001\Services\coreupdater
<img src=hkeycoreupdater.png alt=hkeycoreupdater class=left></li></ol></li></ol></li><li><p>What malicious IP Addresses were involved?
At the time of the attack 194.61.24[.]102 was seen exploiting cve-2015-1635, a &ldquo;HTTP.sys RCE Vuln.&rdquo;</p><ol><li>Were any IP Addresses from known adversary infrastructure?
203.78.103[.]109 also appears in VT associated with Meterpreter</li><li>Are these pieces of adversary infrastructure involved in other attacks around the time of the attack? See above.</li></ol></li><li><p>Did the attacker access any other systems?
Yes</p><ol><li>How?
RDP from DC to Workstation</li><li>When?
From 02:35:54 (Initial logon from DC to Workstation) till 02:35:54</li><li>Did the attacker steal or access any data?
Yes, extracted all .txt files in Fileshare\Secrets directory in the form of a .zip file<ol><li>When?
02:34:18 the zip file was deleted and closed from the DC I could not find a transfer action in the pcap or in the timeline however in DFIR he states it was done at 02:32</li></ol></li></ol></li><li><p>What was the network layout of the victim network?
Network: 10.42.85.0/24
Domain: C137
Hosts:
DC CITADEL-DC01 10.42.85.10
Workstation Desktop-SDN1RPT</p></li><li><p>What architecture changes should be made immediately?
Disable RDP from outside of network. Make a stronger password for Administrator account, create a separate admin account with a unique name and enable/implement MFA</p></li><li><p>Did the attacker steal the Szechuan sauce? If so, what time?</p><ol><li>Yes at 02:32:39</li></ol></li><li><p>Did the attacker steal or access any other sensitive files? If so, what times?
Beth&rsquo;s Secrets were manipulated, renamed and content modified. I have not analyzed the workstation yet, I will do that at a separate time and will likely write a part two to this post.</p></li><li><p>Finally, when was the last known contact with the adversary?
Based on this pcap, attacker disconnected (after laterally spreading to workstation) at 02:52:14</p></li></ol><h3 id=advanced-and-bonus-questions>Advanced and Bonus Questions<a href=#advanced-and-bonus-questions class=hanchor arialabel=Anchor>#</a></h3><ol><li>What CIS Top 20 or SANS Top 20 Controls would have <em>directly</em> prevented this breach?</li><li>What major architecture improvement could be made that would have prevented this breach?
VPN, IPS, MFA, EDR</li><li>Can you identify policy improvements or controls that should be implemented to secure this environment?
Unique username, Complex passwords, IPS, EDR, VPN, MFA, PW Encrypted files if they contain important secrets.</li><li>Which users have actually logged onto the DC?
Administrator was the only one in the Users folder in the DC Disk Image</li><li>Which users have actually logged onto the Desktop machine? Did not check</li><li>What are the passwords for the users in the domain? Did not check</li><li>Can you recover the original file about Beth’s Secrets?<ol><li>What was the original name?
Secret_Beth.txt</li><li>Original Contents?
Earth Beth is the real Beth</li></ol></li><li>Finally, what file was time stomped?
The dupe copy of Secret_Beth.txt named Beth_Secret.txt</li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://BioCreates.github.io/posts/elastic-deep-dive/ class="button inline next">[<span class=button__text>Lab #3 – Elastic Deep Dive: From Sigma to Dashboards</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>